# -*- coding: utf-8 -*-
"""Image Compression

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dvccXY4NAHGkck6qjnjMWY4kSxYxY-fT
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from scipy.fftpack import dct, idct
import os

def create_sample_image(size=512):
    """
    Generates a synthetic test image (Zone Plate), converts it to an
    RGB format (three identical channels) for consistency.
    """
    x = np.linspace(-10, 10, size)
    y = np.linspace(-10, 10, size)
    X, Y = np.meshgrid(x, y)
    R = np.sqrt(X**2 + Y**2)
    img_gray = np.sin(R**2)
    # Normalize to 0-255 uint8
    img_gray = ((img_gray - img_gray.min()) / (img_gray.max() - img_gray.min()) * 255).astype(np.uint8)

    # Stack three identical channels to simulate a color image
    return np.stack([img_gray, img_gray, img_gray], axis=-1)

def load_external_image(file_path):
    """
    Loads an external image file and returns it as an RGB (H x W x 3)
    NumPy array (uint8, 0-255 range).
    """
    if not os.path.exists(file_path):
        print(f"Error: Image file not found at '{file_path}'. Using sample (color) image instead.")
        return create_sample_image(512)

    print(f"Loading image from: {file_path}")
    try:
        img = mpimg.imread(file_path)

        # Convert floating point images (0.0-1.0) to uint8 (0-255)
        if img.dtype == np.float32 or img.dtype == np.float64:
            img = (img * 255).astype(np.uint8)

        # Handle alpha channel if present (4 channels -> 3 channels)
        if len(img.shape) == 3 and img.shape[2] == 4:
            img = img[..., :3]

        # If image is grayscale (2D), stack it to create 3 channels
        if len(img.shape) == 2:
            img = np.stack([img, img, img], axis=-1)

        # Final check to ensure it's a 3-channel RGB image
        if len(img.shape) == 3 and img.shape[2] == 3:
            return img.astype(np.uint8)

        raise ValueError("Unsupported image format or channel count.")

    except Exception as e:
        print(f"An error occurred while loading or processing the image: {e}. Using sample (color) image instead.")
        return create_sample_image(512)

def to_grayscale(image_rgb):
    """
    Converts an RGB image array (H x W x 3) to a grayscale array (H x W)
    using the standard luminosity method (for histogram display).
    """
    # Ensure input is float64 for calculation and normalized to 0-1
    img_float = image_rgb.astype(np.float64) / 255.0

    # Check if already grayscale (2D)
    if len(img_float.shape) == 2:
        return (img_float * 255).astype(np.uint8)

    # Standard luminosity conversion for RGB
    # Grayscale = R*0.2989 + G*0.5870 + B*0.1140
    grayscale = np.dot(img_float[...,:3], [0.2989, 0.5870, 0.1140])
    return (grayscale * 255).astype(np.uint8)


def calculate_metrics(original, compressed):
    """
    Calculates MSE and PSNR. Works on both 2D (grayscale) and 3D (color) arrays.
    """
    # Convert to float64 for accurate calculation
    original = original.astype(np.float64)
    compressed = compressed.astype(np.float64)

    # 1. MSE (calculated across all dimensions/channels)
    mse = np.mean((original - compressed) ** 2)

    # 2. PSNR
    if mse == 0:
        psnr = 100
    else:
        max_pixel = 255.0
        # The PSNR calculation remains the same, using max_pixel=255
        psnr = 20 * np.log10(max_pixel / np.sqrt(mse))

    return mse, psnr

def get_compression_ratio(coeffs, threshold_percent):
    """
    Calculates theoretical compression ratio based on the number of
    coefficients kept vs total elements (pixels * channels).
    """
    total_elements = coeffs.size
    # We kept the top (100 - threshold_percent)% of coefficients
    kept_ratio = (100 - threshold_percent) / 100.0
    non_zero_count = total_elements * kept_ratio

    if non_zero_count == 0: return 0
    return total_elements / non_zero_count


# --- CORE 2D COMPRESSION FUNCTIONS (Unchanged, operate on single channel) ---

def dft_compression(image_channel, threshold_percent):
    # ... (DFT 2D logic remains the same)
    f_transform = np.fft.fft2(image_channel)
    f_shift = np.fft.fftshift(f_transform)
    magnitude = np.abs(f_shift)
    thresh_val = np.percentile(magnitude, threshold_percent)
    mask = magnitude > thresh_val
    compressed_f_shift = f_shift * mask
    f_ishift = np.fft.ifftshift(compressed_f_shift)
    img_back = np.abs(np.fft.ifft2(f_ishift))
    return img_back, compressed_f_shift

def dct_2d(image):
    return dct(dct(image.T, norm='ortho').T, norm='ortho')

def idct_2d(coeffs):
    return idct(idct(coeffs.T, norm='ortho').T, norm='ortho')

def dct_compression(image_channel, threshold_percent):
    # ... (DCT 2D logic remains the same)
    dct_coeffs = dct_2d(image_channel)
    magnitude = np.abs(dct_coeffs)
    thresh_val = np.percentile(magnitude, threshold_percent)
    dct_coeffs_compressed = dct_coeffs * (magnitude > thresh_val)
    img_back = idct_2d(dct_coeffs_compressed)
    img_back = np.clip(img_back, 0, 255)
    return img_back, dct_coeffs_compressed


# --- NEW COLOR WRAPPER FUNCTIONS ---

def dft_compression_color(image_rgb, threshold_percent):
    """Performs DFT compression by iterating over R, G, B channels."""
    compressed_channels = []
    compressed_coeffs = []

    for i in range(3):
        channel = image_rgb[:, :, i].astype(np.float64) # Ensure float processing
        recon, coeffs = dft_compression(channel, threshold_percent)
        compressed_channels.append(recon)
        compressed_coeffs.append(coeffs)

    # Stack the reconstructed channels back into an RGB image
    img_back = np.stack(compressed_channels, axis=-1)

    # The reconstruction can have small complex components due to floating point math;
    # we take the real part and clip to 0-255 for proper display.
    return np.clip(np.real(img_back), 0, 255).astype(np.uint8), np.stack(compressed_coeffs, axis=-1)

def dct_compression_color(image_rgb, threshold_percent):
    """Performs DCT compression by iterating over R, G, B channels."""
    compressed_channels = []
    compressed_coeffs = []

    for i in range(3):
        channel = image_rgb[:, :, i].astype(np.float64) # Ensure float processing
        recon, coeffs = dct_compression(channel, threshold_percent)
        compressed_channels.append(recon)
        compressed_coeffs.append(coeffs)

    # Stack the reconstructed channels back into an RGB image
    img_back = np.stack(compressed_channels, axis=-1)

    # Clip to 0-255 and convert to uint8 for proper display
    return np.clip(img_back, 0, 255).astype(np.uint8), np.stack(compressed_coeffs, axis=-1)


# ==========================================
# Main Execution
# ==========================================

if __name__ == "__main__":
    # 1. Load Image

    # --- OPTION 1: Load an external image (Modify 'input_image.jpg' to your file name) ---
    IMAGE_FILE_PATH = '/content/4.2.07.tiff'
    original_img_rgb = load_external_image(IMAGE_FILE_PATH)

    # Compression Level (Higher = More Compression = Lower Quality)
    # 90 means we discard the bottom 90% of coefficients (keeping top 10%)
    THRESHOLD = 90

    print(f"Running compression keeping only top {100-THRESHOLD}% of coefficients across 3 channels...\n")

    # --- DFT Process (Color) ---
    dft_recon, dft_coeffs = dft_compression_color(original_img_rgb, THRESHOLD)
    mse_dft, psnr_dft = calculate_metrics(original_img_rgb, dft_recon)
    cr_dft = get_compression_ratio(dft_coeffs, THRESHOLD)

    # --- DCT Process (Color) ---
    dct_recon, dct_coeffs = dct_compression_color(original_img_rgb, THRESHOLD)
    mse_dct, psnr_dct = calculate_metrics(original_img_rgb, dct_recon)
    cr_dct = get_compression_ratio(dct_coeffs, THRESHOLD)

    # --- Calculate Difference Maps (Error Maps) ---
    # Calculates the average absolute difference across RGB channels (axis=2)
    original_float = original_img_rgb.astype(np.float64)
    dft_diff_map = np.mean(np.abs(original_float - dft_recon.astype(np.float64)), axis=2)
    dct_diff_map = np.mean(np.abs(original_float - dct_recon.astype(np.float64)), axis=2)

    # --- Convert to Grayscale for Histograms and Console Output ---
    original_gray = to_grayscale(original_img_rgb)
    dft_gray = to_grayscale(dft_recon)
    dct_gray = to_grayscale(dct_recon)

    # --- Output Statistics ---
    print("--- DFT Results (Color) ---")
    print(f"MSE : {mse_dft:.2f}")
    print(f"PSNR: {psnr_dft:.2f} dB")
    print(f"CR  : {cr_dft:.2f}:1")
    print("-" * 20)
    print("--- DCT Results (Color) ---")
    print(f"MSE : {mse_dct:.2f}")
    print(f"PSNR: {psnr_dct:.2f} dB")
    print(f"CR  : {cr_dct:.2f}:1")

    # ==========================================
    # --- Visualization 1: Images ---
    # ==========================================
    plt.figure(figsize=(12, 5))

    # Original Image
    plt.subplot(1, 3, 1)
    plt.title("Original Image (RGB)")
    plt.imshow(original_img_rgb)
    plt.axis('off')

    # DFT Compressed Image
    plt.subplot(1, 3, 2)
    plt.title(f"DFT Compressed\nMSE: {mse_dft:.2f} | PSNR: {psnr_dft:.2f}dB | CR: {cr_dft:.1f}:1")
    plt.imshow(dft_recon)
    plt.axis('off')

    # DCT Compressed Image
    plt.subplot(1, 3, 3)
    plt.title(f"DCT Compressed\nMSE: {mse_dct:.2f} | PSNR: {psnr_dct:.2f}dB | CR: {cr_dct:.1f}:1")
    plt.imshow(dct_recon)
    plt.axis('off')

    plt.tight_layout()


    # ==========================================
    # --- Visualization 2: Histograms ---
    # ==========================================
    plt.figure(figsize=(12, 5))

    # Original Histogram
    plt.subplot(1, 3, 1)
    plt.hist(original_gray.ravel(), bins=256, range=[0, 256], color='black', alpha=0.7)
    plt.title("Original Histogram (Grayscale)")
    plt.xlabel("Pixel Intensity (0-255)")
    plt.ylabel("Frequency")
    plt.xlim(0, 256)

    # DFT Histogram
    plt.subplot(1, 3, 2)
    plt.hist(dft_gray.ravel(), bins=256, range=[0, 256], color='blue', alpha=0.7)
    plt.title(f"DFT Histogram\nMSE: {mse_dft:.2f}")
    plt.xlabel("Pixel Intensity (0-255)")
    plt.ylabel("Frequency")
    plt.xlim(0, 256)

    # DCT Histogram
    plt.subplot(1, 3, 3)
    plt.hist(dct_gray.ravel(), bins=256, range=[0, 256], color='red', alpha=0.7)
    plt.title(f"DCT Histogram\nMSE: {mse_dct:.2f}")
    plt.xlabel("Pixel Intensity (0-255)")
    plt.ylabel("Frequency")
    plt.xlim(0, 256)

    plt.tight_layout()


    # ==========================================
    # --- Visualization 3: Difference Images (Error Maps) ---
    # ==========================================
    plt.figure(figsize=(10, 5))

    # DFT Difference Map
    plt.subplot(1, 2, 1)
    plt.title(f"DFT Difference Map (Avg Abs Error)\nMSE: {mse_dft:.2f}")
    # Using 'viridis' to highlight error intensity, setting vmax for good contrast.
    plt.imshow(dft_diff_map, cmap='viridis', vmin=0, vmax=30)
    plt.colorbar(label='Avg Absolute Error per Pixel (0-255)')
    plt.axis('off')

    # DCT Difference Map
    plt.subplot(1, 2, 2)
    plt.title(f"DCT Difference Map (Avg Abs Error)\nMSE: {mse_dct:.2f}")
    plt.imshow(dct_diff_map, cmap='viridis', vmin=0, vmax=30)
    plt.colorbar(label='Avg Absolute Error per Pixel (0-255)')
    plt.axis('off')

    plt.tight_layout()
    plt.show()